// REQUIRES Version.comp
// REQUIRES ParallelSortConstants.comp
// - WORK_GROUP_SIZE_X/Y/Z
// - ITEMS_PER_WORK_GROUP
// REQUIRES SsboBufferBindings.comp
// - PREFIX_SCAN_BUFFER_BINDING
// REQUIRES OriginalDataBuffer.comp
// REQUIRES IntermediateSortBuffer.comp

uniform uint uIntermediateBufferSize;

/*------------------------------------------------------------------------------------------------
Description:
    Adapt to whatever needs to be sorted as necessary.

    The original data that needs to be sorted may not be a simple set of integers, but rather 
    structures that have integers, floatas, and vec4s and are very unwieldy to move around after 
    every prefix scan during the radix sort.  This shader takes the original data and fills out 
    a simple, intermediate structure that is much more easily moved around.
Parameters: None
Returns:    None
Creator:    John Cox, 3/11/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // Note: The number of items in the IntermediateSortBuffers is equivalent to the number of 
    // items in the PrefixScanBuffer, which will likely exceed the size of the user-provided 
    // data.  The number of threads is managed by ParallelSort::Sort(...) to be the same as the 
    // number of data entries that need to be filled out in the PrefixScanBuffer, so if the 
    // thread ID is greater than the number of user-provided data entries, pad out the 
    // IntermediateData with values of max int.  Do this instead of padding with 0s because the 
    // sorting will put items with the smallest value first, but entries that don't refer to any 
    // real data should be put at the back.  

    IntermediateData newThing;
    uint index = gl_GlobalInvocationID.x;
    newThing._globalIndexOfOriginalData = index;

    if (index < uIntermediateBufferSize)
    {
        newThing._data = AllOriginalData[index]._value;
    }
    else
    {
        newThing._data = 0xffffffff;
    }

    AllIntermediateDataFirstBuffer[index] = newThing;


    // make sure that the uniform uReadFromFirstBuffer in IntermediateSortBuffer is 1 
}
