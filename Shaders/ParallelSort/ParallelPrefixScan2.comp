// REQUIRES Version.comp
// REQUIRES ParallelSortConstants.comp
// REQUIRES UniformLocations.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES PrefixScanBuffer.comp


layout (local_size_x = PARALLEL_SORT_WORK_GROUP_SIZE_X) in;
layout(location = UNIFORM_LOCATION_BIT_NUMBER) uniform uint uBitNumber;
shared uint[ITEMS_PER_WORK_GROUP] fastTempArr;

void main()
{
    // reproduce the end of the "up the tree" loop for a starting position
    uint startingDataPairs = ITEMS_PER_WORK_GROUP >> 1;
    uint dataPairs = uPrefixSumsWithinGroupSize >> 1;
    uint indexMultiplierDueToDepth = 1;
    while (startingDataPairs > 0)
    {
        startingDataPairs >>= 1;            // divide by 2
        dataPairs >>= 1;                    // divide by 2
        indexMultiplierDueToDepth <<= 1;    // multiply by 2
    }

    uint localIndex = gl_LocalInvocationID.x * 2;
    uint lesserSourceIndex = (indexMultiplierDueToDepth * (localIndex + 1)) - 1;
    uint greaterSourceIndex = (indexMultiplierDueToDepth * (localIndex + 2)) - 1;

    //??only need to check one of them??
    if (lesserSourceIndex < uPrefixSumsWithinGroupSize && greaterSourceIndex < uPrefixSumsWithinGroupSize)
    {
        fastTempArr[localIndex] = PrefixSumsWithinGroup[lesserSourceIndex];
        fastTempArr[localIndex + 1] = PrefixSumsWithinGroup[greaterSourceIndex];
    }
    else
    {
        fastTempArr[localIndex] = 0;
        fastTempArr[localIndex + 1] = 0;
    }

    barrier();

    // keep going up
    while (dataPairs > 0)
    {
        barrier();
        if (gl_LocalInvocationID.x < dataPairs)
        {
            uint lesserIndex = (indexMultiplierDueToDepth * (localIndex + 1)) - 1;
            uint greaterIndex = (indexMultiplierDueToDepth * (localIndex + 2)) - 1;

            fastTempArr[greaterIndex] += fastTempArr[lesserIndex];
        }
        indexMultiplierDueToDepth <<= 1;    // *= 2
        dataPairs >>= 1;                    // /= 2
    }

    if (localIndex == 0)
    {
        fastTempArr[ITEMS_PER_WORK_GROUP - 1] = 0;
    }
    indexMultiplierDueToDepth >>= 1;

    // going down
    while (dataPairs < startingDataPairs)
    {
        barrier();
        if (gl_LocalInvocationID.x < dataPairs)
        {
            uint lesserIndex = (indexMultiplierDueToDepth * (localIndex + 1)) - 1;
            uint greaterIndex = (indexMultiplierDueToDepth * (localIndex + 2)) - 1;

            // the algorithm calls for a swap and sum
            uint temp = fastTempArr[lesserIndex];
            fastTempArr[lesserIndex] = fastTempArr[greaterIndex];
            fastTempArr[greaterIndex] += temp;
        }

        indexMultiplierDueToDepth >>= 1;    // /= 2
        dataPairs <<= 1;                    // *= 2
    }

    barrier();

    PrefixSumsWithinGroup[lesserSourceIndex] = fastTempArr[localIndex];
    PrefixSumsWithinGroup[greaterSourceIndex] = fastTempArr[localIndex + 1];
}
